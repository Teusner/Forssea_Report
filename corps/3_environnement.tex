\chapter{Simulation de l'environnement}
\chaptermark{Environnement}
\label{chapitre:environnement}
	
	\section{Introduction}

		Dans ce chapitre, nous allons nous intéresser à la simulation de l'environnement. Elle constitue une partie importante du simulateur car elle va influencer le comportement des \gls{ROV}s dans leur milieu.  A la fin de ce chapitre, nous devrions avoir à notre disposition un environnement de simulation complet proche de l'environnement rencontré lors de missions avec les robots.

		Pour ce faire, nous allons donc d'établir les différents éléments de l'environnement qui vont interagir avec les \gls{ROV}s afin de les intégrer dans le simulateur. Ce qui va principalement influencer le comportement des robots est le milieu marin qui va ajouter la flottabilité, les vagues et des courants marins. Nous allons aussi nous intéresser aux ombilicaux qui relient les \gls{ROV}s au bateau afin de l'alimenter en énergie mais aussi d'avoir un retour d'informations.
		
	\section{Environnement marin}

		\subsection{Introduction}
			
			La simulation de l'environnement marin est probablement ce qui va le plus impacter le comportement des \gls{ROV}s. Le milieu marin doit proposer un modèle de mer avec des vagues, ajouter de la flottabilité aux robots et simuler du courant.

		\subsection{Modélisation de la surface libre}

			\subsubsection{Introduction}

				Dans un premier temps, nous allons nous intéresser à la modélisation de la surface libre de la mer, c’est-à-dire qu'il nous faut trouver un formalisme permettant de simuler la surface de l'environnement marin, à l'interface entre l'air et l'eau.

				Les premières modélisations de la mer étaient des champs de hauteur, c’est-à-dire que pour chaque $(x, y)$ dans le plan de la mer, on y associait au maximum un $z$. Cette modélisation peut aux premiers abords suffire, et elle a d'ailleurs été utilisée pour réaliser les premiers rendus informatiques de mer~\cite{scha80, max81}, comme celui présenté sur la \textsc{Figure}~\ref{fig:carlas_island}. Mais on se rend compte qu'en réalité un champ de hauteur ne suffit pas. En effet, pour décrire une mer comme celle présentée en \textsc{Figure}~\ref{fig:hokusai}, il faut établir l'équation paramétrique de la surface libre, car pour un même couple $(x, y)$ il est possible d'avoir plusieurs $z$ associés si les vagues roulent les unes sur les autres.

				\begin{figure}[!htb]
					\centering
					\begin{subfigure}[t]{0.48\textwidth}
						\includegraphics[width=\textwidth]{imgs/tsunami_hokusai.jpg}
						\caption{La grande vague de Kanagawa, Katsushika Hokusai, 1830~\cite{hokusai_1830}}
						\label{fig:hokusai}
					\end{subfigure}
					\begin{subfigure}[t]{0.5\textwidth}
						\includegraphics[width=\textwidth]{imgs/carlas_island.png}
						\caption{Carla's Island, Max Nelson L., 1981~\cite{max81}}
						\label{fig:carlas_island}
					\end{subfigure}
					\caption{Représentation de la surface libre de la mer}
					\label{fig:representation_mer}
				\end{figure}

				Un modèle établi il y a plus de deux cents par \textit{Gerstner}~\cite{Gerstner} propose une modélisation trochoïdale de la houle. Cette modélisation permet de décrire la forme de la surface libre de l'eau. Cependant elle n'est vraie qu'en eaux profondes, et cette description se concentre sur des vagues dans un plan en deux dimensions $(0, \overrightarrow{x}, \overrightarrow{z})$, avec x orienté dans le sens de propagation de la vague, et z orienté vers le haut. Dans le cas plus général, il est possible d'étendre ce modèle à un environnement en trois dimensions~\cite{Constantin_2001, Gerstner-Like_Henry}, qui est aussi connu sous le nom d'\textit{Airy Wave}, et même à un modèle en eaux peu profondes ou semi-profondes~\cite{dean1991water}. Cette modélisation présente l'avantage d'être linéaire. Il faut cependant s'assurer que les vagues ne déferlent pas afin de ne pas entrer dans le domaine non-linéaire, comme présenté sur la \textsc{Figure}~\ref{fig:hokusai} représentant un tsunami avec des vagues déferlantes. D'après l'échelle de \textit{Beaufort}~\cite{beaufort}, le modèle de vagues linéaire semble acceptable jusqu'à \textit{mer 3}, car au-delà des moutons blancs apparaissent à la surface de la mer et les vagues commencent à déferler. Nous nous limiterons donc à ce domaine pour la simulation de l'environnement, d'autant plus que les robots ne sortent pas en milieu naturel par \textit{mer 4} et au-delà.

			\subsubsection{Formalisme}

				Plaçons-nous dans un repère $(0, \overrightarrow{x}, \overrightarrow{y}, \overrightarrow{z})$ tel que $0$ soit au niveau de la mer au repos, $\overrightarrow{x}$ soit orienté dans le sens de déplacement de la vague, $\overrightarrow{z}$ orienté vers le haut, et $\overrightarrow{y}$ tel que la base formée soit un repère direct. La \textsc{Figure}~\ref{fig:repere} représente une vague dans le repère de l'étude.

				\begin{figure}[!htb]
					\centering
					\begin{tikzpicture}[x={(20:1cm)},y={(90:1cm)},z={(160:1cm)},line join=round,]
							\tikzset{xyp/.style={canvas is xy plane at z=#1}}

							\filldraw[brown!50,draw=black] (0,0,0) -- (3,0,0) -- (3,0.3,0) -- cycle;
							\filldraw[brown!50,draw=black] (0,0,0) -- (3,0.3,0) -- (3,0.3,1.5) -- (0,0,1.5) -- cycle;
							\draw[blue!50!cyan!50!black,thick] (1.5,1,0) -- (1.5,1,1.5);
						
							\foreach \z in {50, ..., 0}
							{   \pgfmathsetmacro{\drawperc}{or(\z==0,\z==50) ? 1 : 0}
								\ifthenelse{\z=0 \OR \z=50}
								{   \gdef\myc{blue!50!cyan!50!black}}
								{ \gdef\myc{blue!30!cyan!30!white}}
								\filldraw[blue!30!cyan!30!white,xyp=\z/100*3,opacity=1,draw=\myc,draw opacity=1] (0,0) -- (3,0.3) -- (3,1) to[out=170,in=0,looseness=1] (1.5,2) to[out=180,in=20] (0,1.5) -- cycle;
							}
						
							\draw[blue!50!cyan!50!black] (0,1.5,0) -- (0,1.5,1.5) -- (0,0,1.5) --(0,0,0);

							\draw[draw=black, fill=gray, opacity=0.2] (0, 0, 0) -- (0, 2.5, 0) -- (3, 2.5, 0) -- (3, 0, 0) -- cycle;
							\draw[draw=black, dotted] (0,1.5,0) node[below left] {$O$} -- (3,1.5,0) -- (3,1.5,1.5) -- (0,1.5,1.5) -- cycle;
							\draw[->, >=stealth, color=red, thick] (0,1.5,0) -- (0.8,1.5,0) node[below right] {$\overrightarrow{x}$};
							\draw[->, >=stealth, color=ForestGreen, thick] (0,1.5,0) -- (0,1.5,0.8) node[below left] {$\overrightarrow{y}$};
  							\draw[->, >=stealth, color=NavyBlue, thick] (0,1.5,0) -- (0,2.3,0) node[above right] {$\overrightarrow{z}$};
						\end{tikzpicture}
						\caption{Modélisation de la vague et repère de l'étude}
						\label{fig:repere}
				\end{figure}


				Cette modélisation de houle trochoïdale utilise une approche lagrangienne pour définir l'équation paramétrique de la surface libre~\cite{Gerstner, Constantin_2001, Gerstner-Like_Henry, dean1991water}. On s'intéresse donc à une particule de fluide positionnée au repos en $p_0=(\alpha, \beta, 0)$, à l'instant $t$, au-dessus d'une colonne d'eau de hauteur $H$. Chaque vague trochoïdale $m$ est ensuite définie par son amplitude $a_m$, son nombre d'onde $k_m$, sa phase $\phi_m$ et sa pulsation $\omega_m$ et va influencer la position de cette particule au cours du temps comme suit :

				\begin{eqnarray}
					\xi(\alpha, \beta, t) & = & \alpha - \sum_{m=0}^{M} \frac{k_{x, m}}{k_m} \cdot \frac{a_m}{tanh(k_m H)} \cdot sin(\theta_m) \label{eqn:xi}\\ 
					\zeta(\alpha, \beta, t) & = & \beta - \sum_{m=0}^{M} \frac{k_{y, m}}{k_m} \cdot \frac{a_m}{tanh(k_m H)} \cdot sin(\theta_m) \label{eqn:zeta}\\ 
					\eta(\alpha, \beta, t) & = & - \sum_{m=0}^{M} a_m \cdot cos(\theta_m) \label{eqn:eta}\\ 
					\theta_m(\alpha, \beta, t) & = & k_{x, m} \alpha + k_{z, m} \beta - \omega_m t - \phi_m \label{eqn:theta}
				\end{eqnarray}

				On a alors défini l'équation paramétrique de la surface libre de l'eau $x = \xi(\alpha, \beta, t)$, $y = \zeta(\alpha, \beta, t)$, et $z = \eta(\alpha, \beta, t)$. La relation de dispersion relie la pulsation $\omega_m$ de chaque signal au nombre d'onde $k_m$, et $k_{x, m}$ et $k_{y, m}$ sont les composantes du vecteur nombre d'ondes dans le plan de la mer tel que  :
				
				\begin{eqnarray}
					\omega_m^2 & = & g \cdot k_m \cdot tanh(k_m H) \label{equation:dispersion} \\
					k_m & = & \sqrt{k_{x, m}^2 + k_{y, m}^2} \label{equation:nombre_onde}
				\end{eqnarray}

				Dès lors, il est possible de définir $k_{x, m}$ et $k_{y, m}$ en introduisant le cap de la vague $h_m$ par rapport au repère présenté en \textsc{Figure}~\ref{fig:repere} :

				\begin{eqnarray}
					k_{x, m} & = & cos(h_m) \cdot k_m \\
					k_{y, m} & = & sin(h_m) \cdot k_m \\
				\end{eqnarray}

				Ainsi les expressions de $k_{x, m}$ et $k_{y, m}$ vérifient l'\textsc{Equation}~\ref{equation:nombre_onde} et sont calculées uniquement à partir des valeurs de $k_m$ et de $h_m$.
				
				La forme de la vague est définie par les différents paramètres de la vague. On peut par exemple s'intéresser au produit adimensionné $a_m\cdot k_m$. La \textsc{Figure}~\ref{fig:amkm} présente le profil d'une vague pour un produit valant $0.1$ un autre égal à $1$, et un dernier valant $1.2$. On se rend compte que jusqu'à une valeur de $1$ les vagues sont réalistes, mais qu'au-delà, une boucle se forme. C'est à cet endroit que le modèle linéaire des vagues s'arrête, car la crête va en réalité s'effondrer au lieu de former une boucle, la vague va déferler et de l'écume va s'y former~\cite{Gerstner-Like_Henry, Gerstner_Pixar}. On veillera donc à ne pas dépasser cette valeur charnière afin de rester dans le domaine linéaire, mais aussi afin d'avoir une simulation réaliste.

				\begin{figure}[!htb]
					\centering
					\includegraphics{build/imgs/gerstner_wave.pdf}
					\caption{Vagues de Gerstner pour différentes valeurs de $a_m\cdot k_m$}
					\label{fig:amkm}
				\end{figure}

				Enfin, une amélioration proposée par A. \textsc{Fournier}~\cite{Gerstner_Pixar} est d'ajouter un terme sur la phase permettant de faire accélérer les crêtes de vagues, et de faire ralentir les creux. C'est quelque chose que l'on retrouve réellement sur les vagues, et cela permet d'orienter les vagues suivant la direction de leur déplacement. L'\textsc{Equation}~\ref{equation:pixar_phase} donne la nouvelle expression de la phase. Le terme ajouté introduit un paramètre $\gamma_m$ permettant de gérer l'intensité de l'effet ajouté, et $z$ qui est la hauteur de la particule considérée. L'effet est réparti linéairement suivant la hauteur de la vague, et en $z=0$ aucun changement de phase n'a lieu car le terme s'annule. La \textsc{Figure}~\ref{fig:gerstner_pixar} montre comment l'ajout de ce paramètre de phase agit sur la forme de la vague.

				\begin{equation}
					\theta_m(\alpha, \beta, t) = k_{x, m} \alpha + k_{z, m} \beta - \omega_m t - \phi_m - \gamma_m z
					\label{equation:pixar_phase}
				\end{equation}

				\begin{figure}[!htb]
					\centering
					\includegraphics{build/imgs/gerstner_pixar.pdf}
					\caption{Forme de la vague en fonction du paramètre $\gamma_m$}
					\label{fig:gerstner_pixar}
				\end{figure}

				Cependant, si ce modèle suffit à représenter la surface libre de la mer, il ne fournit pas la dynamique du milieu marin et l'impact qu'il va voir sur les \gls{ROV}s. C'est pourquoi il va falloir établir les équations de vitesse des particules et de pression afin de pouvoir pleinement simuler le milieu marin.
				
			\subsubsection{Dynamique du milieu}

				Après avoir défini la forme de la surface libre de la mer, il faut désormais établir les équations du mouvement des particules de fluides dans l'eau~\cite{dean1991water, MIT_Waves}. Il faut notamment définir leur position notée $(x, y, z)$, leur vitesse notée $(u, v, w)$, et établir l'équation de pression notée $p$. La hauteur $z$ étant prise par rapport au repère présenté en \textsc{Figure}~\ref{fig:repere}, cette valeur est souvent négative, sauf quand une vague élève localement le niveau de l'eau au-dessus du niveau nul.

				En continuant à utiliser le formalisme précédemment introduit, on est en mesure d'étendre les \textsc{Equations}~\ref{eqn:xi} à \ref{eqn:eta} à tous les points de l'espace immergés en s'aidant des références bibliographiques~\cite{dean1991water, MIT_Waves} :

				\begin{eqnarray}
					\xi(\alpha, \beta, z, t) & = & \alpha - \sum_{m=0}^{M} a_m \cdot cos(h_m) \cdot \frac{cosh(k_m(z+H))}{sinh(k_m H)} \cdot sin(\theta_m) \\
					\zeta(\alpha, \beta, z, t) & = & \beta - \sum_{m=0}^{M} a_m \cdot sin(h_m) \cdot \frac{cosh(k_m(z+H))}{sinh(k_m H)} \cdot sin(\theta_m) \\
					\eta(\alpha, \beta, z, t) & = & z - \sum_{m=0}^{M} \frac{a_m}{k_m} \cdot \frac{sinh(k_m(z+H))}{sinh(k_mh)} \cdot cos(\theta_m)
				\end{eqnarray}

				Puis, on peut établir les équations de vitesse des particules de la même manière, en dérivant temporellement les équations de positions :
		
				\begin{eqnarray}
					v(\alpha, \beta, z, t) & = & \sum_{m=0}^{M} a_m \cdot sin(h_m) \cdot \omega_m \cdot \frac{cosh(k_m(z+H))}{sinh(k_m H)} \cdot cos(\theta_m) \\
					u(\alpha, \beta, z, t) & = & \sum_{m=0}^{M} a_m \cdot cos(h_m) \cdot \omega_m \cdot \frac{cosh(k_m(z+H))}{sinh(k_m H)} \cdot cos(\theta_m) \\
					w(\alpha, \beta, z, t) & = & - \sum_{m=0}^{M} \frac{a_m}{k_m} \cdot \omega_m \cdot \frac{sinh(k_m(z+H))}{sinh(k_m H)} \cdot sin(\theta_m)
				\end{eqnarray}

				Enfin, il nous reste à établir l'équation de pression :

				\begin{equation}
					p(\alpha, \beta, z, t) = \rho \sum_{m=0}^{M} \frac{a_m\omega_m^2}{k} \cdot \frac{cosh(k_m(z+H))}{sinh(k_m H)} \cdot cos(\theta_m) - \rho g z
				\end{equation}

				Ces équations prennent en compte l'impact significatif de la hauteur de la colonne d'eau dans le cas où les vagues sont présentes dans un milieu de faible profondeur. De plus, il est intéressant de remarquer que l'impact des vagues sur la dynamique des particules diminue quand la profondeur augmente, comme le montre la \textsc{Figure}~\ref{fig:speed_pressure_depth}. Cet effet se trouve dans les termes en cosinus et sinus hyperboliques qui décroissent très vite vers 0 quand on s'approche du fond, et qui valent 1 en $z=0$. Ainsi on remarque que la vitesse des particules décroît rapidement vers une vitesse nulle à mesure que la profondeur augmente et la pression n'est impactée que proche de la surface où elle est légèrement supérieure à la pression qu'il y aurait eu sans vagues.

				\begin{figure}[!htb]
					\centering
					\includegraphics[]{build/imgs/gerstner_velocity_pressure_depth.pdf}
					\caption{Evolution de la vitesse des particules et de la pression en fonction de la profondeur à $t=0$, $\alpha=0$ et $\beta=0$, pour une vague d'amplitude $a_m=1\ m$ et de nombre d'onde $k_m = 1\ rad.m^{-1}$}
					\label{fig:speed_pressure_depth}
				\end{figure}

			\subsubsection{Simplification en eaux profondes}
			\label{sec:simplification_eaux_profondes}
			
				Finalement, on peut simplifier le modèle précédent, en remarquant que la hauteur de la colonne d'eau dans notre cas est très grande devant la longueur d'onde caractéristique de nos vagues. Une explication plus détaillée de la simplification est disponible en \textsc{Annexe}~\ref{annexe:deep_water}. On déduit de cette simplification, que pour une hauteur de colonne d'eau très grande devant la longueur d'onde des vagues :

				\begin{equation}\frac{cosh(k_m(z+H))}{sinh(k_mH)} \approx e^{k_mz} \label{eqn:simplification_eaux_profondes}\end{equation}

				Comme $z$ est négatif sous la surface de l'eau, ce terme est une exponentielle décroissante qui va atténuer fortement l'effet des vagues au fond et avoir un effet plus conséquent sur les premiers mètres d'eau. On peut montrer que la distance caractéristique d'atténuation est de l'ordre d'une demi-longueur d'onde. En effet, en notant $\lambda_m$ la longueur d'onde de la vague, on a $k_m = \tfrac{2\pi}{\lambda_m}$, et en évaluant l'expression en $z = - \tfrac{\lambda_m}{2}$, $e^{-\tfrac{k_m\lambda_m}{2}} = e^{-\pi} \approx 0,05$. Cela signifie que $95 \%$ de l'effet des vagues est dissipé sur une demi-longueur d'onde de profondeur. Avec cette simplification, les équations de position se simplifient comme suit :
			
				\begin{eqnarray}
					\xi(\alpha, \beta, z, t) & = & \alpha - \sum_{m=0}^M a_m \cdot cos(h_m) \cdot e^{k_mz} \cdot sin(\theta_m) \\
					\zeta(\alpha, \beta, z, t) & = & \beta - \sum_{m=0}^M a_m \cdot sin(h_m) \cdot e^{k_mz} \cdot sin(\theta_m) \\
					\eta(\alpha, \beta, z, t) & = & z - \sum_{m=0}^M a_m \cdot e^{k_mz} \cdot cos(\theta_m) \\
				\end{eqnarray}

				Les équations de vitesse des particules de fluides se simplifient comme suit :

				\begin{eqnarray}
					u(\alpha, \beta, z, t) & = & \sum_{m=0}^M a_m \cdot cos(h_m) \cdot \omega_m \cdot e^{k_mz} \cdot cos(\theta_m) \\
					u(\alpha, \beta, z, t) & = & \sum_{m=0}^M a_m \cdot sin(h_m) \cdot \omega_m \cdot e^{k_mz} \cdot cos(\theta_m) \\
					w(\alpha, \beta, z, t) & = & - \sum_{m=0}^M a_m \cdot \omega_m \cdot e^{k_mz} \cdot sin(\theta_m) \\
				\end{eqnarray}

				Pour l'équation de pression au sein du milieu et l'équation de dispersion qui lie la pulsation de la vague à son nombre d'onde, elles se simplifient comme suit :

				\begin{eqnarray}
					p(\alpha, \beta, z, t) & = & \rho g \sum_{m=0}^M a_m \cdot e^{k_mz} \cdot cos(\theta_m) - \rho g z\\
					\omega_m^2 & = & k_m \cdot g \label{equation:deep_dispersion}
				\end{eqnarray}

			\subsubsection{Choix du spectre de vagues}

				L'avantage de cette modélisation linéaire des vagues est qu'il est possible d'additionner des vagues de caractéristiques différentes en utilisant le principe de superposition. Ainsi on peut définir un environnement marin réaliste en ajoutant l'effet de plusieurs vagues sur les particules de fluides. L'idée va donc être de définir une vague principale,avec une amplitude de l'ordre du mètre, qui aura donc un très faible nombre d'onde pour respecter la condition $a_m \cdot k_m \le 1$. Puis, on ajoute à cette vague des vaguelettes d'amplitudes moindres qui auront des nombres d'ondes plus élevées afin de rider la surface de l'eau et d'obtenir un résultat réaliste.

				Pour une optimisation en termes de calculs, il est possible de prendre des nombres d'ondes tombant sur la grille qui va servir de support pour réaliser le rendu de la surface libre~\cite{tessendorf2001simulating}. Par la relation de dispersion, cela va créer des vagues avec des pulsations multiples les unes des autres, ce qui va permettre d'avoir un phénomène périodique. Il est donc possible de pré-calculer sur une période tous les paramètres dynamiques de l'environnement, et ainsi de baisser la charge de calculs lors de la simulation. Pour notre cas cela ne sera pas nécessaire, d'abord car la charge de calculs demandée ne ralentit pas la simulation, mais aussi car nous ne voulons pas forcément nous limiter à un phénomène de vagues périodiques.
			
			\subsubsection{Implémentation de la solution}

				Cette modélisation a menée à l'implémentation d'une classe contenant tous les paramètres des vagues de l'environnement. Elle permet de réaliser tous les calculs nécessaires à la simulation visuelle et dynamique du milieu marin modélisé. Cette classe est ensuite instanciée par un \textit{plugin} \gazebo{} de type \textit{WorldPlugin} qui s'applique donc sur le monde simulé, et qui a pour rôle de publier les paramètres du monde marin sur le réseau de communication \textit{ignition transport}, mais aussi de répondre aux requêtes envoyées par d'autres plugins sur la dynamique de l'eau à une certaine position passée en paramètre. 
				
				Pour réaliser le rendu visuel de la mer, on peut créer une grille de particules de fluides pour laquelle on va pouvoir réaliser le rendu de la position au cours du temps. A chaque instant, on actualise la position de chaque particule de fluide et on trace à nouveau la grille. On est alors en mesure d'obtenir le résultat visualisable en \textsc{Figure}~\ref{fig:Gerstner} dans \gazebo{}, obtenu à l'aide de trois vagues dont les caractéristiques sont présentées dans la \textsc{Table}~\ref{table:wave} et tracé sur une grille de 40 mètres par 40 mètres avec un pas de 1 mètre. Les paramètres des vagues ainsi que de la grille de rendu sont passées en paramètre au \plugin{} implémenté afin de pouvoir rapidement plonger les \gls{ROV}s dans des milieux ayant des dynamiques différentes.

				\begin{figure}[!htb]
					\begin{minipage}[c]{0.45\textwidth}
						\centering
						\includegraphics[width=\textwidth]{imgs/gerstner.jpg}
						\caption{Vagues dans \gazebo{}}
						\label{fig:Gerstner}
					\end{minipage} \hfill
					\begin{minipage}[c]{0.54\textwidth}
						\centering
						\begin{adjustbox}{max width=\textwidth}
							\begin{tabular}{c c c c c c}
								\toprule
								\textbf{Vague} & $a_m$ ($m$) & $k_m$ ($rad.m^{-1}$) & $\phi_m$ ($rad$) & $h_m$ ($rad$) & $\gamma_m (rad.m^{-1})$ \\
								\midrule
								Vague 1 & 1.2 & 0.06 & 0 & 0 & 0.5\\
								Vague 2 & 0.6 & 0.1 & 0 & 0.8 & 0.3\\
								Vague 3 & 0.2 & 1 & 0 & -0.3 & 0\\
								\bottomrule
							\end{tabular}
						\end{adjustbox}
						\caption{Caractéristiques des vagues simulées}
						\label{table:wave}
					\end{minipage}
				\end{figure}

		\subsection{Forces induites par le milieu}

			\subsubsection{Introduction}
			
				Les forces qui s'appliquent sur un solide immergé dans un fluide en mouvement sont la poussée d'Archimède~\cite{dean1991water}, les forces de Morison~\cite{morison1950force, dean1991water} et celles de Froude-Krylov~\cite{dean1991water}. Elles permettent d'appliquer les forces que subit les objets immergés. Les forces de Morison et les forces de Froude-Krylov possèdent cependant quelques limitations~\cite{dean1991water, sarpkaya2010wave} :

				\begin{itemize}[noitemsep]
					\item[\textbullet] L'accélération du fluide doit être relativement uniforme autour de la structure. Dans notre cas, cela implique que la longueur d'onde des vagues doit être grande devant la longueur caractéristique du robot ou de la structure considérée. Comme les robots ont une longueur caractéristique de l'ordre du mètre, on doit respecter $\forall m, \lambda_m \gg 1 m$. \\
					\item[\textbullet] L'écoulement doit être unidirectionnel. Cela implique que les vagues doivent globalement rester dans la même direction. C'est un phénomène observable en milieu marin à condition que l'étude reste relativement courte dans le temps. Cela implique aussi que l'écoulement doit rester laminaire, d'abord afin de pouvoir rester dans le domaine linéaire de la description des vagues, mais aussi pour éviter les turbulences et donc que l'expression des forces proposée ne suffise plus. \\
					\item[\textbullet] Les forces proposées sont basées sur des expressions asymptotiques des forces d'inerties et de traînée. Elles sont donc justes en régime permanent, mais elles changent significativement en régime transitoire et les forces ne décrivent plus exactement les forces qui s'appliquent sur un corps. Aucune précaution ne peut être prise dans notre cas, mais il faudra garder à l'esprit que pendant le régime transitoire de l'accélération du robot les forces appliquées ne seront pas exactement celles que le robot réel subit.
				\end{itemize}

				Après ces quelques hypothèses, nous allons détailler le calcul de ces forces afin de les ajouter aux solides simulés dans l'environnement marin et donc d'avoir une dynamique satisfaisante comme le requiert la fonction contrainte \textbf{FP1}.

			\subsubsection{Poussée d'Archimède}

				La poussée d'Archimède est une force générée par le volume fluide déplacé par un corps immergé dans ce fluide. Elle s'applique donc à tout solide qui sera immergé. En notant $V_i$ le volume immergé du solide, $\rho$ la masse volumique du fluide considéré et $g$ l'accélération de pesanteur, on a :

				\begin{equation}
					\overrightarrow{\Pi_A} = - \rho \cdot V_i \cdot \overrightarrow{g}
				\end{equation}

			\subsubsection{Force de Froude-Krylov}

				La force de \textit{Froude-Krylov} est la force générée par le champ de pression des vagues sur la surface mouillée du solide. En notant $\overrightarrow{u}$ la vitesse du fluide, alors $\overrightarrow{\dot{u}}$ est l'accélération du fluide, et on a :

				\begin{equation}
					\overrightarrow{F_{fk}} = \rho \cdot V_i \cdot \overrightarrow{\dot{u}}
				\end{equation}

			\subsubsection{Force de masse ajoutée hydrodynamique}

				La force de masse ajoutée hydrodynamique est la force qui va prendre en compte la masse de fluide déplacée par le robot lors de ses mouvements. Elle vient du fait que lors de l'application du principe fondamental de la dynamique, la masse ajoutée de fluide $m_A$ s'ajoute à la masse du robot. En notant $\overrightarrow{a}$ l'accélération du robot, on a donc on a l'apparition d'une force d'expression :
				
				\begin{equation}
					\overrightarrow{F_{am}} = - m_A \cdot \overrightarrow{a}
				\end{equation}

			\subsubsection{Force de traînée hydrodynamique}

				La force de traînée hydrodynamique est la force qui va s'opposer au déplacement du solide dans le fluide. Cette force est une force non-conservative qui est indispensable à la stabilité de la simulation, car elle va supprimer les éventuelles oscillations induites par les méthodes d'intégration numériques utilisées par le simulateur. Cette force est en outre très importante dans le cas d'une simulation dans un fluide ayant une grande masse volumique, comme l'eau dans notre cas. En notant $\rho$ la masse volumique du fluide, $Cd$ la coefficient de traînée hydrodynamique, $u$ la vitesse du fluide, $v$ la vitesse du robot, $A$ la surface mouillée du robot, c'est-à-dire la section qui s'oppose au déplacement du robot dans le fluide, on a :

				\begin{equation}
					\overrightarrow{F_{hm}} = \frac{1}{2} \cdot \rho \cdot C_d \cdot A \cdot |\overrightarrow{u} - \overrightarrow{v}| \cdot (\overrightarrow{u} - \overrightarrow{v})
				\end{equation}

				Puis, en supposant que la sphère est immergée jusqu'à une , on est en mesure d'exprimer le volume immergé 

			\subsubsection{Estimation du volume immergé}

				Les forces précédentes nécessitent de connaître le volume du solide immergé dans le fluide qui ici est l'eau. Une possibilité est d'estimer le volume immergé numériquement~\cite{gilloteaux:tel-00521689}, mais cela s'avère assez coûteux en calculs. Une autre solution est de considérer que le solide se rapproche d'une sphère de même volume $V$ que le solide. On choisit une sphère, car toute section plane va former une calotte sphérique dont le volume est facilement calculable. Cette sphère a donc un rayon $r$ égal à :

				\begin{equation}
					r = \sqrt[3]{\frac{3 V}{4 \pi}}
				\end{equation}

				Le volume immergé et donc le volume de la calotte sphérique de hauteur $h \in [0; 2r]$ est calculable par intégration et le calcul est détaillé en \textsc{Annexe}~\ref{annexe:calotte_spherique} :

				\begin{equation}
					V_i = \pi h^2\frac{3r-h}{3} \label{eqn:v_immerge}
				\end{equation}


			\subsubsection{Ajout des forces aux solides}

				Un \plugin{} a été développé pour \gazebo{} afin d'appliquer ces forces à chaque objet auquel on souhaite y ajouter la dynamique du milieu. Ce plugin communique avec le \plugin{} implémenté pour l'environnement afin de récupérer la masse volumique du milieu ainsi que l'accélération et la vitesse du fluide à la position du centre de volume des \gls{ROV}s. Le plugin va ensuite calculer à chaque itération la somme des forces induites par le milieu et va les ajouter à la simulation du solide via l'\textit{API}\footnote{Application Programming Interface : Interface de Programmation} \gazebo{}. Le moteur physique va ensuite se charger d'ajouter ces forces aux autres forces qui s'appliquent déjà au solide comme le poids, puis d'intégrer l'accélération du solide pour en obtenir sa vitesse et sa position.

		\subsection{Courants marins}

			\subsubsection{Introduction}

				Les courants marins constituent un élément majeur qui va perturber le comportement des robots dans l'environnement simulé. Avec une simulation suffisamment précise, la simulation et le comportement réel des \gls{ROV}s deviendront très proches, notamment par l'ajout de la traînée hydrodynamique qui va s'appliquer sur les composants des robots.

			\subsubsection{Modèle constant}

				Pour simuler ces courants, il est possible d'utiliser en première approximation une idée assez triviale : localement le courant est constant. Par constant on entend uniforme et stationnaire, donc qui ne dépend ni de l'espace ni du temps. C’est-à-dire qu'il est possible de considérer le courant marin comme un champ de vecteurs ayant un certain cap et une certaine magnitude représentant la vitesse de l'écoulement, comme présenté sur la \textsc{Figure}~\ref{fig:constant}. Ce modèle simple permet de rapidement ajouter du courant dans notre simulateur, mais ce courant est peu réaliste dans la mesure où il ne prend pas du tout en compte la présence de structures sous-marine qui pourraient modifier la vitesse et l'orientation de ce courant, comme des reliefs sous-marins ou bien des piles d'éoliennes à inspecter dans le cas de \forssea{}.

				\begin{figure}[!htb]
					\centering
					\includegraphics{build/imgs/courant_constant.pdf}
					\caption{Modèle de courant constant}
					\label{fig:constant}
				\end{figure}

			\subsubsection{Modèle procédural}

				Une autre idée serait de générer un courant pseudo-aléatoire par génération procédurale. Cette méthode de génération est largement utilisée dans le domaine des jeux-vidéos et du cinéma, et par extension, il est aussi utilisé dans le domaine de la simulation~\cite{generation_procedurale_monde, volumetric_terrain_generation}. Elle permet de générer à l'aide d'algorithme des mondes et des textures pseudo-aléatoires. Dans notre cas, il est possible d'utiliser le \textit{Bruit de Perlin}~\cite{PerlinNoise} qui est une texture procédurale afin de générer des courants. L'avantage du \textit{Bruit de Perlin} est qu'il est très peu coûteux en espace mémoire et qu'il peut générer des textures dans n'importe quelle dimension. 
				
				Pour notre application, nous pouvons générer une texture en deux dimensions. Cette texture forme un potentiel artificiel et un champ de vecteurs représentant le courant peut être simplement généré en prenant le gradient de ce potentiel. On obtient le résultat présenté en \textsc{Figure}~\ref{fig:perlin_noise}. Comme avec cette méthode, chaque pixel tient compte de ses pixels voisins, on ne se retrouve pas avec des valeurs très éloignées entre deux pixels adjacents comme avec de la génération de textures purement aléatoire, et on obtient des courants réalistes.

				\begin{figure}[!htb]
					\centering
					\begin{subfigure}[b]{0.32\textwidth}
						\centering
						\includegraphics{build/imgs/noise_random.pdf}
						\caption{Bruit aléatoire}
					\end{subfigure}
					\hfill
					\begin{subfigure}[b]{0.32\textwidth}
						\centering
						\includegraphics{build/imgs/noise_perlin.pdf}
						\caption{Bruit de Perlin}
					\end{subfigure}
					\hfill
					\begin{subfigure}[b]{0.32\textwidth}
						\centering
						\includegraphics{build/imgs/noise_courant.pdf}
						\caption{Courant généré}
					\end{subfigure}
					\caption{Comparaison bruit aléatoire et bruit de Perlin}
					\label{fig:perlin_noise}
				\end{figure}

				C'est une bonne approche pour générer des courants marins de manière pseudo-aléatoire, mais il est difficile de reproduire de manière contrôlée les courants marins qu'il y aurait eu lors d'un essai en milieu naturel afin de comparer les résultats de la simulation avec le comportement des \gls{ROV}s réels.
				
				Il serait cependant intéressant d'utiliser ce genre d'algorithme pour de la génération procédurale de terrain. En effet, en interprétant la carte 2D comme un modèle d'élévation numérique de terrain, on serait en mesure de créer de manière pseudo-aléatoire des fonds marins pour tester les robots dans différents environnements.

			\subsubsection{Modèle de Navier-Stokes}

				Une simulation des courants marins basée sur les équations de Navier-Stokes permet de proposer une approche intéressante à la simulation de courants marins~\cite{Garau2006current}. Ils permettent notamment de générer des courants prenant en compte la présence de solides dans le milieu à explorer, comme des rochers ou des piles d'éoliennes \textit{offshores} qui peuvent être intéressantes pour notre application. C'est la méthode qui fournirait les résultats les plus vraisemblables et les plus proches de ce qu'on pourrait trouver en milieu naturel.

				En revanche les équations de Navier-Stokes sont des équations aux dérivées partielles non-linéaires~\cite{hinch2012hydrodynamique} qui sont lourdes à résoudre numériquement. Elles alourdiraient grandement la simulation afin de calculer le courant en chaque point de l'espace afin d'impacter tous les solides constituants les robots, mais aussi les éléments de l'environnement comme les structures sous-marines et les ombilicaux par exemple.

			\subsubsection{Choix du modèle}

				Il faut maintenant choisir un modèle qui va être implémenté dans le simulateur. Pour nous aider dans ce choix, la \textsc{Table}~\ref{table:courants} reprends les principales caractéristiques des différents modèles, à savoir le caractère non-aléatoire des courants générés et la prise en compte des structures sous-marines. Le réalisme des courants générés ainsi que la complexité d'implémentation est aussi présentée. Cette dernière représente à la fois le temps d'implémentation de la solution ainsi que la complexité d'exécution de celle-ci en termes de ressources nécessaires. Elle est représentée par le symbole \pmark (\pmark : \textit{simple}, \pmark \pmark : \textit{intermédiaire}, \pmark \pmark \pmark : \textit{complexe}).

				\begin{table}[ht]
					\centering
					\begin{adjustbox}{max width=\textwidth}
						\begin{tabular}{|c|c|c|c|c|}
							\hline
							\textbf{Modèle de courants} & \textbf{Non aléatoire} & \textbf{Structures sous-marines} & \textbf{Réalisme} & \textbf{Complexité} \\
							\hline
							Modèle constant & \cmark & \xmark & \pmark \pmark & \pmark\\
							\hline
							Modèle procédural & \xmark & \xmark & \pmark & \pmark \pmark \\
							\hline
							Modèle Navier-Stokes & \cmark & \cmark & \pmark \pmark \pmark & \pmark \pmark \pmark \\
							\hline
						\end{tabular}
					\end{adjustbox}
					\caption{Différents modèles de simulation de courants}
					\label{table:courants}
				\end{table}

				Nous pouvons aisément écarter le modèle procédural car on remarque au vu des éléments présentés sur la \textsc{Table}~\ref{table:courants} qu'il n'est pas adapté à notre simulateur. Quant au modèle de Navier-Stokes, il est bien trop lourd à mettre en place, et les calculs sont très coûteux en termes de ressources pour une simulation temps réel. Notre choix se porte donc sur l'utilisation du modèle constant dans la mesure où il fournit un niveau de réalisme suffisant à l'échelle locale de nos essais qui est intéressante dans notre application, pour un niveau de complexité très faible. Il faudra tout de même garder à l'esprit que le modèle ne prends pas en compte les courants, ce qui constitue une limite pour notre simulateur.

		\section{Simulation d'ombilicaux}

			\subsection{Etat de l'art}

				La simulation de câble en temps réel est un domaine qui présente encore des lacunes. En effet, formaliser le mouvement de tels objets implique l'utilisation d'équations différentielles aux dérivées partielles non-linéaires et le mouvement des solides attachés aux extrémités du câble sont dynamiquement dépendants~\cite{blintsov_development_2017}.

				Les solutions proposées dans la littérature pour simuler la physique d'un câble est de procéder par éléments finis~\cite{bender_simulation_methods} pour calculer la position de chaque élément au cours du temps. L'idée est de discrétiser le câble en $n$ éléments reliés les uns aux autres et de faire le bilan des forces qui s'appliquent à chaque élément pour simuler correctement le comportement du câble~\cite{ellis_modeling, blintsov_development_2017,marshall,ganoni_unreal, koenemann_modeling_2017, prabhakar_dynamics_2005}. Nous allons utiliser cette méthode afin de simuler l'ombilical qui relie les \gls{ROV}s au bateau ou à d'autres structures sous-marines.

				Le problème introduit par cette méthode de simulation est qu'on ne connaît pas les forces que va induire un élément à ses voisins. Il est possible de proposer une expression analytique de cette force en utilisant la mécanique des milieux continus~\cite{koenemann_modeling_2017, prabhakar_dynamics_2005}, mais il est aussi possible de proposer un modèle comportemental de cette force basé sur l'utilisation d'un correcteur proportionnel sur l'erreur de distance entre deux éléments adjacents~\cite{ellis_modeling,ganoni_unreal,blintsov_development_2017}.

				Nous allons proposer ici un modèle comportemental de cette force et nous allons voir dans quelle mesure cette modélisation est physiquement acceptable. Cette solution va aller plus loin que celle proposée par les autres références~\cite{ganoni_unreal,blintsov_development_2017} dans la mesure où l'on va proposer un correcteur proportionnel-intégral-dérivé afin d'obtenir un résultat satisfaisant.

			\subsection{Formalisme}

				Supposons que nous voulons simuler un ombilical de longueur $L$. On va alors le diviser en un nombre fini de n\oe uds $n$ connectés par des liens. Ces liens doivent donc avoir une longueur $l=\frac{L}{n-1}$.
			
				Pour cette simulation, nous allons prendre en compte le poids noté $\overrightarrow{P}$, la flottabilité notée $\overrightarrow{\Pi}$, la force exercée par l'élément précédant sur l'élément considéré notée $\overrightarrow{F_p}$, tout comme celle exercée par l'élément suivant notée $\overrightarrow{F_s}$, et enfin la force de frottements fluides notée $\overrightarrow{F_f}$.
				
				\begin{description}
					\item [Bilan des Forces] \
					\begin{itemize}
						\item[\textbullet] \textbf{Poids $\overrightarrow{P}$} : En considérant que chaque élément a une masse $m$, et en notant $g$ l'accélération de pesanteur, on a : 
						
						\begin{equation}
							\overrightarrow{P} = \begin{bmatrix}0\\ 0\\ -m.g\end{bmatrix}
							\label{eq:poids}
						\end{equation}
				
						\item[\textbullet] \textbf{Poussée d'Archimède $\overrightarrow{\Pi}$} : Si on note le volume d'un élément $V$ et $\rho$ la masse volumique du fluide dans lequel est immergé l'ombilical, on a : 
						
						\begin{equation}
							\overrightarrow{\Pi} = \begin{bmatrix}0\\ 0\\ \rho.V.g\end{bmatrix}
							\label{eq:archimede}
						\end{equation}
				
						\item[\textbullet] \textbf{Traînée hydrodynamique $\overrightarrow{F_f}$} : En notant $A$ la surface de référence, $C_D$ le coefficient de traînée, $\rho$ la masse volumique du fluide, et $\overrightarrow{v}$ la vitesse du n\oe ud, on a : 
					
						\begin{equation}
							\overrightarrow{F_f} = - \frac{1}{2} \cdot \rho \cdot A \cdot C_D \cdot ||\overrightarrow{v}|| \cdot \overrightarrow{v}
							\label{eq:drag}
						\end{equation}
						
						\item[\textbullet] \textbf{Force inter-éléments $\overrightarrow{F_p}$ et $\overrightarrow{F_s}$} : Il est difficile de trouver une forme analytique pour décrire cette force. Nous allons ici proposer un modèle comportemental pour ces forces. Nous savons que chaque n\oe ud doit se trouver à une distance $l$ de ses voisins. En notant $p_{p}$ la position du n\oe ud précédent et $p_{c}$ la position du n\oe ud considéré, en introduisant les trois coefficients $K_p$, $K_d$ et $K_i$ qui vont nous permettre de régler la dynamique du système, on est en mesure de proposer le modèle de force comportemental suivant :
						
						\begin{equation}
							\overrightarrow{F} = - \left(K_p \cdot e(t) + K_d \cdot \dot e(t) + K_i \cdot \int_{0}^te(\tau) \cdot d\tau \right) \cdot \overrightarrow{u}
							\label{eq:pid}
						\end{equation}
						
						Dans cette expression, $\overrightarrow{u}$ est le vecteur unitaire orienté du n\oe ud courant vers le n\oe ud voisin, $e$ est l'erreur de positionnement du n\oe ud, $\dot e$ est la dérivée de cette erreur et $\int_{0}^te(\tau) \cdot d\tau$ est l'intégrale de cette erreur. La dérivée et l'intégrale de cette erreur sont estimées numériquement en utilisant respectivement la méthode d'Euler et la méthode des rectangles. On trouve les expressions de $\overrightarrow{u}$ et $e(t)$ pour deux éléments en position $\overrightarrow{p_c}$ et $\overrightarrow{p_p}$ tel que $||\overrightarrow{p_c} - \overrightarrow{p_p}|| \neq 0$ :

						\begin{equation}
							\overrightarrow{u} = \frac{\overrightarrow{p_c} - \overrightarrow{p_p}}{||\overrightarrow{p_c} - \overrightarrow{p_p}||} \qquad e(t) = \frac{||\overrightarrow{p_c} - \overrightarrow{p_p}|| - l}{||\overrightarrow{p_c} - \overrightarrow{p_p}||}
							\label{eq:behavioral}
						\end{equation}
						
						Les deux forces $\overrightarrow{F_p}$ et $\overrightarrow{F_s}$ peuvent enfin être exprimées en utilisant l'expression de $\overrightarrow{F}$ et en prenant soin d'adapter les expressions de $\overrightarrow{u}$ et $e(t)$ en actualisant l'élément courant et l'élément précédent.
					\end{itemize}
				\end{description}
			
				Ainsi on a exprimé les forces nécessaires à la simulation de l'ombilical par éléments finis. La \textsc{Figure}~\ref{fig:modelization} montre la modélisation du problème. Les différents n\oe uds sont représentés en bleu. Pour des raisons de clarté, les différentes forces ne sont représentées que sur un seul n\oe ud mais sont bien évidemment appliquées sur tous les n\oe uds, et la représentation de l'ombilical est volontairement tronquée.
			
				\begin{figure}[!htb]
					\centering
					\begin{tikzpicture}
						\tikzstyle{TetherElement}=[circle,draw,fill=RoyalBlue]
						\tikzstyle{Link}=[thick,black]
						\tikzstyle{vector}=[-stealth,Red,very thick]
						\tikzset{ext/.pic={
							\path [fill=white] (-0.2,0)to[bend left](0,0.1)to[bend right](0.2,0.2)to(0.2,0)to[bend left](0,-0.1)to[bend right](-0.2,-0.2)--cycle;
							\draw (-0.2,0)to[bend left](0,0.1)to[bend right](0.2,0.2) (0.2,0)to[bend left](0,-0.1)to[bend right](-0.2,-0.2);
						}}
			
						\foreach \x in {1, 2, 3, 4, 5}
							\node[TetherElement] (T\x) at ({1.5*(\x-3)+3.5}, {8*cosh(0.25*(\x-3))-7}) {};
			
						\draw[Link] (T1) -- pic[rotate=45,scale=0.6] {ext} (T2);
						\draw[Link] (T2) -- (T3) -- (T4);
						\draw[Link] (T4) -- pic[rotate=-70,scale=0.6] {ext} (T5);
						
						\node (fp) at ($(T2)!.3!(T3)$) {};
						\draw[vector] (T3) -- (fp) node[yshift=1em]{$\overrightarrow{F_p}$};
			
						\node (fn) at ($(T3)!.7!(T4)$) {};
						\draw[vector] (T3) -- (fn) node[yshift=1em]{$\overrightarrow{F_n}$};
						\draw[vector] (T3) -- +(270:1cm) node[yshift=-.6em]{$\overrightarrow{P}$};
						\draw[vector] (T3) -- +(90:1cm) node[yshift=.6em]{$\overrightarrow{\Pi}$};
						\draw[vector] (T3) -- +(225:0.8cm) node[xshift=-.5em]{$\overrightarrow{F_f}$};
						\draw[vector,Green] (T3) -- +(45:1cm) node[xshift=.2em,yshift=.4em]{$\overrightarrow{v}$};
			
						\draw[->,red,very thick, >=stealth] (0,0) -- (-0.4,-0.6) node[left] {$\mathbf{x}$}; 
						\draw[->,Green,very thick, >=stealth] (0,0) -- (1,0) node[above left] {$\mathbf{y}$}; 
						\draw[->,blue,very thick, >=stealth] (0,0) -- (0,1) node[above] {$\mathbf{z}$}; 
					\end{tikzpicture}
					\caption{Modélisation du problème}
					\label{fig:modelization}
				\end{figure}
			
			
			\subsection{Initialisation}
				L'initialisation des différents n\oe uds de l'ombilical est une étape importante, car les coefficients du modèle comportemental sont réglés pour avoir un comportement cohérent lorsque la position du câble a convergée. Si l'initialisation est aléatoire, le temps du régime transitoire peut être long et la simulation peut ne pas être consistante. De plus il faut impérativement que deux n\oe uds adjacents n'aient pas la même position, sinon l'expression de $\overrightarrow{u}$ dans l'\textsc{Equation}~\ref{eq:behavioral} n'est plus valable, car le dénominateur n'annule.
			
				Pour initialiser l'ombilical, nous allons nous appuyer sur l'équation de la chaînette. Cette équation représente la forme que prend une corde attachée à ses deux extrémités, sachant qu'elle va chercher à minimiser son énergie potentielle. L'équation de la chaînette est valable pour une corde attachée à ses extrémités en $(-x_0, y_0, z_0)$ et $(x_0, y_0, z_0)$.
				
				Dans notre cas, notre ombilical va pouvoir être attaché à deux extrémités aux positions $p_1 = (x_1, y_1, z_1)$ et $p_n = (x_n, y_n, z_n)$ qui peuvent être quelconque, nous allons devoir ajouter deux coefficients $c_2$ et $c_3$ à la solution de l'équation de la chaînette permettant de translater sa représentation graphique dans le plan. Ainsi la forme que va prendre notre ombilical lors de l'initialisation va être régie par l'\textsc{Equation}~\ref{eq:tether}.
			
				\begin{equation}
					z = c_1\cdot cosh\left(\frac{x + c_2}{c_1}\right) + c_3
					\label{eq:tether}
				\end{equation}
			
				Il nous reste à estimer les trois paramètres $c_1$, $c_2$ et $c_3$ introduits à partir des conditions aux limites. Les contraintes sont telles que les deux extrémités de l'ombilical doivent se trouver en $p_1$ et en $p_n$, et le câble doit avoir une longueur $L$. Ces trois contraintes se traduisent par le système non-linéaire de trois équations à trois inconnues présenté en \textsc{Equation}~\ref{eq:systeme} à résoudre.
				
				\begin{align}
					S_1 = 
					\begin{cases}
						L   = & c_1 \cdot sinh\left(\dfrac{x_n+c_2}{c_1}\right) - c_1 \cdot sinh\left(\dfrac{x_1+c_2}{c_1}\right) \\
						z_1 = & c_1 \cdot cosh\left(\dfrac{x_1+c_2}{c_1}\right)+c_3 \\
						z_n = & c_1 \cdot cosh\left(\dfrac{x_n+c_2}{c_1}\right)+c_3
					\end{cases}
					\label{eq:systeme}
				\end{align}
			
				\begin{figure}[!htb]
					\centering
					\begin{subfigure}[b]{0.45\textwidth}
						\begin{tikzpicture}[scale=1.2]
							\begin{axis}[view={125}{20},
								axis lines=center,axis on top,
								xlabel=$x$,ylabel=$y$,zlabel=$z$,
								no marks,axis equal,
								xmin=0,xmax=7,ymin=0,ymax=6,zmin=0,zmax=7,
								enlargelimits={upper=0.1}]
				
								% R0
								\draw[thick,->, red] (0,0,0) -- (1,0,0) node[anchor=north east] (x0) {\tiny $\overrightarrow{x_0}$};
								\draw[thick,->, green] (0,0,0) -- (0,1,0) node[anchor=north west] (y0) {\tiny $\overrightarrow{y_0}$};
								\draw[thick,->, blue] (0,0,0) -- (0,0,1) node[anchor=south] (z0) {\tiny $\overrightarrow{z_0}$};
				
								% R1
								\draw[thick,->, red] (7,2,6.769) -- ++(-0.4,0.8,0) node[anchor=west] (x1) {\tiny $\overrightarrow{x_1}$};
								\draw[thick,->, blue] (7,2,6.769) -- ++(0,0,1) node[anchor=south] (z1) {\tiny $\overrightarrow{z_1}$};
				
								% Tether
								\addplot3[
									samples y=0,
									smooth, thick, color=purple,
									domain=2:7
									] ({8-0.5*x},{x},{cosh(x-4.6)});
								
								% label points
								\node [above] at (7,0,0) {\tiny $x_1$};
								\node [above] at (0,2,0) {\tiny $y_1$};
								\node [above] at (4.5,0,0) {\tiny $x_n$};
								\node [above] at (0,7,0) {\tiny $y_n$};
				
								% Dots
								\draw[dotted] (7,0,0) -- (7,2,0) -- (0,2,0);
								\draw[dotted] (7,2,0) -- (7,2,6.769);
								
								\draw[dotted] (4.5,0,0) -- (4.5,7,0) -- (0,7,0);
								\draw[dotted] (4.5,7,0) -- (4.5,7,5.556);
							\end{axis}
						\end{tikzpicture}
						\caption{Dans le repère du monde}
						\label{fig:3d_plot}
					\end{subfigure}
					\hfill
					\begin{subfigure}[b]{0.45\textwidth}
						\begin{tikzpicture}
							\begin{axis}[
									xmin=-1,   xmax=9,
									ymin=-1,   ymax=8,
									grid=both,
									axis lines=middle,
									minor tick num=5,
									enlargelimits={abs=0.5},
									axis line style={latex-latex},
									ticklabel style={font=\tiny,fill=white},
									xlabel style={at={(ticklabel* cs:1)},anchor=north west},
									ylabel style={at={(ticklabel* cs:1)},anchor=south west}
								]
								\addplot [
									domain=2:7, 
									samples=100, 
									color=purple,
									]
									{cosh(\x - 4.6)};
								\addlegendentry{$Ombilical$}
			
								% Labels
								\node[below] at (2,0) {\tiny $x_1$};
								\node[below] at (7,0) {\tiny $x_n$};
								\node[left] at (0,6.769) {\tiny $z_1$};
								\node[left] at (0,5.556) {\tiny $z_n$};
								\node[left] at (0,1) {\tiny $c_3 + 1$};
								\node[below] at (4.6, 0) {\tiny $c_2$};
			
								% Dots
								\draw[dotted] (2,0) -- (2,6.769) -- (0,6.769);
								\draw[dotted] (4.6,0) -- (4.6,1) -- (0,1);
								\draw[dotted] (7,0) -- (7,5.556) -- (0,5.556);
							\end{axis}
						\end{tikzpicture}
						\caption{Dans le repère de l'ombilical}
						\label{fig:2d_plot}
					\end{subfigure}
					\caption{Modélisation de l'ombilical en 3 dimensions}
					\label{fig:tether_plot}
				\end{figure}
				
				Pour résoudre ce système et trouver une approximation numérique pour $c_1$, $c_2$ et $c_3$, on utilise un solveur numérique. Lors de l'implémentation pour le simulateur de cette étape d'initialisation, la librairie \textit{GSL}\footnote{\url{https://www.gnu.org/software/gsl/}} est utilisée. Une fois les paramètres déterminés, on est en mesure de déterminer la position initiale de chaque n\oe ud dans le repère de l'ombilical. Il faut enfin projeter ces positions dans le repère du monde afin de pouvoir correctement initialiser chaque n\oe uds, comme présenté sur la \textsc{Figure}~\ref{fig:tether_plot}
			
			\subsection{Couple transmissible}

				L'ombilical est capable de transmettre un couple longitudinal capable de traverser le câble et de se transmettre d'un bout à l'autre. Pour simuler ce couple, il va falloir ajouter une variable au vecteur d'état de chaque \textit{TetherElement}. Cette variable va contenir l'angle de chaque n\oe ud. Ensuite, un couple va être appliqué à chaque n\oe ud en fonction de son angle et de celui de son précédent voisin. Encore une fois, nous n'avons pas d'expression analytique pour ce couple, mais nous allons proposer un modèle comportemental permettant d'avoir un comportement physiquement acceptable.

				Le couple proposé peut être simplement un couple proportionnel à la différence d'angles entre l'élément courant et son élément précédent. Ici nous n'avons pas besoin de rejeter une erreur statique à l'aide d'un intégrateur dans la mesure où un ombilical réel peut encaisser un certain nombre de tours sur lui-même sans qu'il ne cherche à vouloir se dérouler complètement. Ainsi, en notant $K_c$ le coefficient permettant de gérer l'intensité de ce couple, $\theta_n$ l'angle de l'élément courant et $\theta_{n-1}$ l'angle de l'élément précédant, le couple ajouté au modèle s'exprime comme :

				\begin{equation}
					C = K_c \cdot (\theta_n - \theta_{n - 1})
				\end{equation}

				Le réglage de $K_c$ dépendra directement des caractéristiques mécaniques de l'ombilical et permettra de simuler des câbles avec plus ou moins de raideur vis-à-vis d'un couple transmissible le long de l'ombilical.
				
				Cependant, un problème survient avec la représentation numérique de l'orientation des solides. Celle-ci est souvent normalisée et les valeurs sont ainsi ramenées dans l'intervalle $[-\pi; \pi]$. On ne peut donc pas avoir l'orientation absolue, c’est-à-dire l'orientation d'un solide en prenant en compte les éventuels tours qu'il aurait pu faire sur lui-même et c'est le cas dans \gazebo{}.
			
				Pour résoudre ce problème, l'\textsc{Algorithme}~\ref{algo:suivi_angle} de suivi d'angles normalisés a été implémenté. Il prend en paramètres l'angle normalisé ainsi que l'angle précédemment calculé, et il retourne la valeur de l'angle absolu. En fournissant l'angle précédent on peut retourner le nouvel angle qui se trouve dans le même quadrant et ainsi de pouvoir suivre les sauts d'angles. On peut donc suivre l'orientation absolue de solides en rotation dans l'espace, en ne fournissant que des orientations relatives ramenées dans l'intervalle $[-\pi; \pi]$, et en gardant en mémoire la précédente orientation calculée.
				
				\begin{algorithm}[!htb]
					\SetKwInOut{Input}{Entrées}
					\SetKwInOut{Output}{Sorties}
					\Entree{$angle\_normalise$, $angle\_absolu$}
					\Sortie{$angle\_absolu$}
					\Deb{
						$offset \leftarrow (angle\_absolu - angle\_normalise + \pi ) \pmod{2\pi}$ \\
						$angle\_absolu \leftarrow angle\_normalise + 2\pi \cdot offset$ \\
					}
					\Retour{$angle\_absolu$}
			
					\caption{Suivi d'angle} 
					\label{algo:suivi_angle}
				\end{algorithm}
			
				La \textsc{Figure}~\ref{fig:suivi_angle} présente les résultats de l'\textsc{Algorithme}~\ref{algo:suivi_angle} avec un angle variant dans l'intervalle $[-3\pi; 3\pi]$. On voit sur la première sous-figure l'angle réel et l'angle ramené dans l'intervalle $[-\pi; \pi]$ avec la présence de saut d'angles. Avec cette méthode, on est capable de suivre l'évolution de l'angle et de supprimer ces sauts afin de retrouver l'angle absolu visible dans la deuxième sous-figure et calculé uniquement à partir de la connaissance de l'angle normalisé. Cet algorithme ne marche en revanche que pour une variation d'angle continue, car en cas de saut brusque d'angle les tours ajoutés ne seront pas pris en compte.
			
				\begin{figure}[!htb]
					\centering
					\includegraphics[]{build/imgs/absolute_orientation_tracking.pdf}
					\caption{Suivi d'angle}
					\label{fig:suivi_angle}
				\end{figure}		

			\subsection{Implémentation}

				L'implémentation d'un \plugin{} \gazebo{} permet de simuler le comportement de l'ombilical dans l'environnement de simulation. Ce \plugin{} est basé sur l'instanciation d'objets de type \textit{Tether} et \textit{TetherElement}. L'objet \textit{Tether} possède les paramètres de simulation de l'ombilical, tandis que l'objet \textit{TetherElement} représente un tronçon de cet ombilical. Un diagramme de classe est présenté en \textsc{Figure}~\ref{fig:uml_class} et montre les différents attributs et méthodes associées à chaque classe.
				est opéré
				\begin{figure}[!htb]
					\centering
					\resizebox{0.50\textwidth}{!}{
						\begin{tikzpicture}
							\begin{class}[text width=6cm]{Tether}{0,0}
								\attribute{+ element\_mass : double}
								\attribute{+ element\_volume : double}
								\attribute{+ element\_length : double}
								\attribute{+ position\_first : numpy.ndarray}
								\attribute{+ position\_last : numpy.ndarray}
								\attribute{+ elements : list of \textit{TetherElement}}
							\end{class}
						
							\begin{class}[text width=6cm]{TetherElement}{8.5,0}
								\attribute{+ mass : double}
								\attribute{+ volume : double}
								\attribute{+ length : double}
								\attribute{+ position : numpy.ndarray}
								\attribute{+ velocity : numpy.ndarray}
								\attribute{+ acceleration : numpy.ndarray}
								\attribute{+ previous : TetherElement}
								\attribute{+ next : TetherElement}
								\attribute{+ K\_p : double}
								\attribute{+ K\_d : double}
								\attribute{+ K\_i : double}
								\operation{+ F\_p(self) : numpy.ndarray}
								\operation{+ F\_b(self) : numpy.ndarray}
								\operation{+ F\_f(self) : numpy.ndarray}
								\operation{+ Ft\_prev(self) : numpy.ndarray}
								\operation{+ Ft\_next(self) : numpy.ndarray}
							\end{class}
						
							\aggregation{Tether}{}{~~~n}{TetherElement}
						\end{tikzpicture}
					}
					\caption{Diagramme de classe UML des classes \textit{Tether} et \textit{TetherElement}}
					\label{fig:uml_class}
				\end{figure}
				
				La \textit{Tether} utilise une structure de \textit{liste doublement chaînée}\footnote{structure de données liée qui consiste en un ensemble n\oe uds liés les uns aux autres par des références au n\oe uds voisins.} de \textit{TetherElement}. Chaque \textit{TetherElement} possède alors une référence vers l'élément le précédant et l'élément le suivant, comme le montre la \textsc{Figure}~\ref{fig:doubly_linked_list}. La \textit{Tether} ne possède ainsi qu'une référence vers le premier et le dernier n\oe ud de la chaîne, nommés respectivement \textit{head} et \textit{tail}. Il est ensuite possible de parcourir la chaîne de \textit{TetherElement} dans les deux sens en utilisant les références gardées par les \textit{TetherElement} eux-mêmes. 
			
				\begin{figure}[!htb]
					\centering
					\resizebox{0.90\textwidth}{!}{
						\begin{tikzpicture}
							\tikzset{TE/.style={draw, inner sep=0, outer sep=0, fill=yellow!20}}
			
							\node[TE, fill=red!20] (TE0) at (0,0) {\begin{tabular}{c} \textit{TetherElement} \\ \hline \hfill \textit{prev} \hfill \vline \hfill \textit{next} \hfill \\ \hline data \end{tabular}};
			
							\node[TE, fill=red!20] (TE4) at (16,0) {\begin{tabular}{c} \textit{TetherElement} \\ \hline \hfill \textit{prev} \hfill \vline \hfill \textit{next} \hfill \\ \hline data \end{tabular}};
			
							\foreach \i in {1,3} {
								\node[TE] (TE\i) at (4*\i,0) {\begin{tabular}{c} \textit{TetherElement} \\ \hline \hfill \textit{prev} \hfill \vline \hfill \textit{next} \hfill \\ \hline data \end{tabular}};
							}
							\node[minimum width=80] (TE2) at (8,0) {\dots};
							\foreach \i in {0,1,2,3} {
								\pgfmathtruncatemacro{\next}{\i +1}
								\draw[<->] (TE\i) -- (TE\next);
							}
			
							\node (head) at (0,1) {\textit{head}};
							\node (tail) at (16,1) {\textit{tail}};
						\end{tikzpicture}
					}
					\caption{Liste doublement chaînée}
					\label{fig:doubly_linked_list}
				\end{figure}

				A chaque pas de temps, on va actualiser la position des \textit{TetherElement}. Les extrémités peuvent être libres, dans ce cas on les traite comme les autres \textit{TetherElement}, ou bien attachée à des solides, dans ce cas la position actualisée est celle de l'élément auquel l'extrémité est attachée. Puis, on parcours la \textit{liste doublement chaînée} et on réalise le bilan des forces qui s'appliquent sur chaque élément. D'après le Principe Fondamental de la Dynamique, en notant $\overrightarrow{a}$ l'accélération d'un \textit{TetherElement}, on a :

				\begin{equation}
					m.\overrightarrow{a_{t_{i+1}}} = \overrightarrow{P} + \overrightarrow{\Pi} + \overrightarrow{F_f} + \overrightarrow{F_p} + \overrightarrow{F_s}
					\label{eq:newton}
				\end{equation}

				A ce stade, on peut appliquer l'accélération des \textit{TetherElement} aux extrémités dans les solides auxquels l'ombilical est attaché. Par exemple si l'ombilical simulé est attaché à un robot, il va induire une force à celui-ci qui va le gêner dans ses mouvements. Cette force est égale à l'opposé de la somme des forces calculées dans l'élément en extrémité d'ombilical.
				
				Ensuite, à l'aide de la méthode d'Euler on est en mesure d'obtenir une approximation de la vitesse puis de la position de chaque élément. En notant $\overrightarrow{v}$ la vitesse et $\overrightarrow{p}$ la position d'un \textit{TetherElement}, et $h$ le pas de temps entre deux instants de calculs, on a :

				\begin{eqnarray}
					\overrightarrow{v_{t_{i+1}}} & = & \overrightarrow{v_{t_i}} + h.\overrightarrow{a_{t_{i+1}}} \\
					\overrightarrow{p_{t_{i+1}}} & = & \overrightarrow{p_{t_i}} + h.\overrightarrow{v_{t_{i+1}}}
					\label{eq:euler}
				\end{eqnarray}

				On a donc actualisé la position de chaque \textit{TetherElement}. Après avoir actualisé la représentation graphique de cet élément dans \gazebo{}, on est prêt pour la prochaine itération de calcul.
			
		\subsection{Résultats}
			
			Le résultat de l'implémentation de l'ombilical est visible sur la \textsc{Figure}~\ref{fig:tether} dans l'environnement de simulation \gazebo{}.
			
			\begin{figure}[!htb]
				\centering
				\includegraphics[width=0.8\textwidth]{imgs/tether_gazebo.png}
				\caption{Tether simulée avec 10 n\oe uds entre deux cubes}
				\label{fig:tether}
			\end{figure}
			
			L'ombilical est attaché à ses extrémités à deux cubes flottants et il prend bien une forme de chaînette afin de minimiser son énergie potentielle. Si l'on cherche à éloigner les cubes l'un de l'autre, l'ombilical va avoir tendance à les ramener du fait du poids qui s'applique sur lui, et une rotation d'un cube va avoir tendance à faire tourner l'autre sur lui-même du fait du couple transmissible le long de l'ombilical. Enfin, il est possible de dérouler l'ombilical en ajoutant des \textit{TetherElement} entre le premier et le deuxième n\oe ud, et de l'enrouler en supprimant le deuxième n\oe ud (car le premier est celui qui est fixé au cube). L'ombilical va réguler sa longueur avec les n\oe uds supplémentaires ou manquants et cela aura pour effet de pouvoir contrôler la longueur de l'ombilical dans l'environnement de simulation.

			Les coefficients du modèle comportemental sont réglés afin d'avoir un comportement réaliste. Pour cet exemple nous avons utilisé un coefficient proportionnel $K_p = 200$, un coefficient dérivé $K_d = 35$ et un coefficient intégral $K_i = 100$.

			En traçant la distance entre chaque n\oe uds au cours du temps, on obtient la \textsc{Figure}~\ref{fig:length}. On se rend compte que le comportement de l'ombilical est consistant et que la longueur de chaque lien converge très vite vers la longueur consigne. Ainsi l'ombilical prends très vite la longueur consigne. 
			
			En traçant l'erreur relative de longueur de l'ombilical par rapport à la longueur consigne au cours du temps, on obtient la \textsc{Figure}~\ref{fig:error_length}. On voit sur cette figure que lors de l'initialisation, l'ombilical va s'étendre un peu avant de converger vers sa longueur consigne avec des légères oscillations. On remarque que l'initialisation à l'aide de l'équation de la chaînette a bien marché dans la mesure où l'erreur relative initiale de longueur est de $0 \%$. On peut expliquer le pic d'erreur relative par le fait que les n\oe uds sont soumis à une forte perturbation liée au poids, alors que la partie intégrale et dérivée du modèle comportemental des forces n'entre pas encore en jeu du fait de l'initialisation récente, mais qu'ils finissent bien par faire converger le système.

			\begin{figure}[!htb]
				\begin{subfigure}[t]{0.45\textwidth}
					\scalebox{0.8}{\input{imgs/length.pgf}}
					\caption{Longueur des liens entre les n\oe uds au cours du temps}
					\label{fig:length}
				\end{subfigure}
				\hfill
				\begin{subfigure}[t]{0.45\textwidth}
					\scalebox{0.8}{\input{imgs/error_length.pgf}}
					\caption{Erreur relative de longueur de l'ombilical par rapport à la longueur consigne}
					\label{fig:error_length}
				\end{subfigure}
			\end{figure}